# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `acts_as_list` gem.
# Please instead update this file by running `bin/tapioca gem acts_as_list`.


# source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#3
module ActiveRecord
  class << self
    # source://activerecord/7.0.8.1/lib/active_record.rb#277
    def action_on_strict_loading_violation; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#277
    def action_on_strict_loading_violation=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#270
    def application_record_class; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#270
    def application_record_class=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#213
    def async_query_executor; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#213
    def async_query_executor=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#183
    def default_timezone; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#187
    def default_timezone=(default_timezone); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#311
    def dump_schema_after_migration; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#311
    def dump_schema_after_migration=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#321
    def dump_schemas; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#321
    def dump_schemas=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#365
    def eager_load!; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#296
    def error_on_ignored_order; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#296
    def error_on_ignored_order=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record/gem_version.rb#5
    def gem_version; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#236
    def global_executor_concurrency; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#228
    def global_executor_concurrency=(global_executor_concurrency); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#216
    def global_thread_pool_async_query_executor; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#240
    def index_nested_attribute_errors; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#240
    def index_nested_attribute_errors=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#171
    def lazily_load_schema_cache; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#171
    def lazily_load_schema_cache=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#180
    def legacy_connection_handling; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#180
    def legacy_connection_handling=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#258
    def maintain_test_schema; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#258
    def maintain_test_schema=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#340
    def query_transformers; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#340
    def query_transformers=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#255
    def queues; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#255
    def queues=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#355
    def raise_int_wider_than_64bit; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#355
    def raise_int_wider_than_64bit=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#200
    def reading_role; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#200
    def reading_role=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#177
    def schema_cache_ignored_tables; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#177
    def schema_cache_ignored_tables=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#288
    def schema_format; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#288
    def schema_format=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#328
    def suppress_multiple_database_warning; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#328
    def suppress_multiple_database_warning=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#302
    def timestamped_migrations; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#302
    def timestamped_migrations=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#347
    def use_yaml_unsafe_load; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#347
    def use_yaml_unsafe_load=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#248
    def verbose_query_logs; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#248
    def verbose_query_logs=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#337
    def verify_foreign_keys_for_fixtures; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#337
    def verify_foreign_keys_for_fixtures=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record/version.rb#7
    def version; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#267
    def warn_on_records_fetched_greater_than; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#267
    def warn_on_records_fetched_greater_than=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#197
    def writing_role; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#197
    def writing_role=(_arg0); end

    # source://activerecord/7.0.8.1/lib/active_record.rb#362
    def yaml_column_permitted_classes; end

    # source://activerecord/7.0.8.1/lib/active_record.rb#362
    def yaml_column_permitted_classes=(_arg0); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#4
module ActiveRecord::Acts; end

# source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#5
module ActiveRecord::Acts::List; end

# source://acts_as_list//lib/acts_as_list/active_record/acts/add_new_at_method_definer.rb#3
module ActiveRecord::Acts::List::AddNewAtMethodDefiner
  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/add_new_at_method_definer.rb#4
    def call(caller_class, add_new_at); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/aux_method_definer.rb#3
module ActiveRecord::Acts::List::AuxMethodDefiner
  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/aux_method_definer.rb#4
    def call(caller_class); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/callback_definer.rb#3
module ActiveRecord::Acts::List::CallbackDefiner
  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/callback_definer.rb#4
    def call(caller_class, add_new_at); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#7
module ActiveRecord::Acts::List::ClassMethods
  # Configuration options are:
  #
  # * +column+ - specifies the column name to use for keeping the position integer (default: +position+)
  # * +scope+ - restricts what is to be considered a list. Given a symbol, it'll attach <tt>_id</tt>
  #   (if it hasn't already been added) and use that as the foreign key restriction. It's also possible
  #   to give it an entire string that is interpolated if you need a tighter scope than just a foreign key.
  #   Example: <tt>acts_as_list scope: 'todo_list_id = #{todo_list_id} AND completed = 0'</tt>
  # * +top_of_list+ - defines the integer used for the top of the list. Defaults to 1. Use 0 to make the collection
  #   act more like an array in its indexing.
  # * +add_new_at+ - specifies whether objects get added to the :top or :bottom of the list. (default: +bottom+)
  #                   `nil` will result in new items not being added to the list on create.
  # * +sequential_updates+ - specifies whether insert_at should update objects positions during shuffling
  #   one by one to respect position column unique not null constraint.
  #   Defaults to true if position column has unique index, otherwise false.
  #   If constraint is <tt>deferrable initially deferred<tt>, overriding it with false will speed up insert_at.
  # * +touch_on_update+ - configuration to disable the update of the model timestamps when the positions are updated.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#24
  def acts_as_list(options = T.unsafe(nil)); end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#67
module ActiveRecord::Acts::List::InstanceMethods
  # Get the current position of the item in the list
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#69
  def current_position; end

  # Decrease the position of this item without adjusting the rest of the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#147
  def decrement_position; end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#205
  def default_position; end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#209
  def default_position?; end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#152
  def first?; end

  # Return the next higher item in the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#163
  def higher_item; end

  # Return the next n higher items in the list
  # selects all higher items by default
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#170
  def higher_items(limit = T.unsafe(nil)); end

  # Test if this record is in a list
  #
  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#197
  def in_list?; end

  # Increase the position of this item without adjusting the rest of the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#141
  def increment_position; end

  # Insert the item at the given position (defaults to the top position of 1).
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#75
  def insert_at(position = T.unsafe(nil)); end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#79
  def insert_at!(position = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#157
  def last?; end

  # Return the next lower item in the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#180
  def lower_item; end

  # Return the next n lower items in the list
  # selects all lower items by default
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#187
  def lower_items(limit = T.unsafe(nil)); end

  # Swap positions with the next higher item, if one exists.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#98
  def move_higher; end

  # Swap positions with the next lower item, if one exists.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#84
  def move_lower; end

  # Move to the bottom of the list. If the item is already in the list, the items below it have their
  # position adjusted accordingly.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#113
  def move_to_bottom; end

  # Move to the top of the list. If the item is already in the list, the items above it have their
  # position adjusted accordingly.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#120
  def move_to_top; end

  # Move the item within scope. If a position within the new scope isn't supplied, the item will
  # be appended to the end of the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#135
  def move_within_scope(scope_id); end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#201
  def not_in_list?; end

  # Removes the item from the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#126
  def remove_from_list; end

  # Sets the new position and saves it
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#214
  def set_list_position(new_position, raise_exception_if_save_fails = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#487
  def active_record_version_is?(version_requirement); end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#228
  def acts_as_list_list; end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#483
  def acts_as_list_order_argument(direction = T.unsafe(nil)); end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#250
  def add_to_list_bottom; end

  # Poorly named methods. They will insert the item at the desired position if the position
  # has been set manually using position=, not necessarily the top or bottom of the list:
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#235
  def add_to_list_top; end

  # Forces item to assume the bottom position in the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#292
  def assume_bottom_position; end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#264
  def assume_default_position?; end

  # Forces item to assume the top position in the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#297
  def assume_top_position; end

  # Returns the bottom item
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#281
  def bottom_item(except = T.unsafe(nil)); end

  # Returns the bottom position number in the list.
  #   bottom_position_in_list    # => 2
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#275
  def bottom_position_in_list(except = T.unsafe(nil)); end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#449
  def check_scope; end

  # This check is skipped if the position is currently the default position from the table
  # as modifying the default position on creation is handled elsewhere
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#463
  def check_top_position; end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#445
  def clear_scope_changed; end

  # This has the effect of moving all the higher items up one.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#323
  def decrement_positions_on_higher_items(position); end

  # This has the effect of moving all the lower items up one.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#328
  def decrement_positions_on_lower_items(position = T.unsafe(nil)); end

  # Increments position (<tt>position_column</tt>) of all items in the list.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#339
  def increment_positions_on_all_items; end

  # This has the effect of moving all the higher items down one.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#302
  def increment_positions_on_higher_items; end

  # This has the effect of moving all the lower items down one.
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#308
  def increment_positions_on_lower_items(position, avoid_id = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#391
  def insert_at_position(position, raise_exception_if_save_fails = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#439
  def internal_scope_changed?; end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#431
  def position_before_save; end

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#423
  def position_before_save_changed?; end

  # When using raw column name it must be quoted otherwise it can raise syntax errors with SQL keywords (e.g. order)
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#470
  def quoted_position_column; end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#479
  def quoted_position_column_with_table_name; end

  # Used in order clauses
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#475
  def quoted_table_name; end

  # Overwrite this method to define the scope of the list changes
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#271
  def scope_condition; end

  # Reorders intermediate items to support moving an item from old_position to new_position.
  # unique constraint prevents regular increment_all and forces to do increments one by one
  # http://stackoverflow.com/questions/7703196/sqlite-increment-unique-integer-field
  # both SQLite and PostgreSQL (and most probably MySQL too) has same issue
  # that's why *sequential_updates?* check alters implementation behavior
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#348
  def shuffle_positions_on_intermediate_items(old_position, new_position, avoid_id = T.unsafe(nil)); end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#221
  def swap_positions_with(item); end

  # source://acts_as_list//lib/acts_as_list/active_record/acts/list.rb#411
  def update_positions; end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#6
module ActiveRecord::Acts::List::NoUpdate
  mixes_in_class_methods ::ActiveRecord::Acts::List::NoUpdate::ClassMethods

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#119
  def act_as_list_no_update?; end

  class << self
    # @return [Boolean]
    #
    # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#98
    def applied_to?(klass); end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#91
    def apply_to(klasses); end

    # @private
    #
    # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#8
    def included(base); end

    private

    # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#108
    def add_klass(klass); end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#104
    def extracted_klasses; end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#113
    def remove_klass(klass); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#12
class ActiveRecord::Acts::List::NoUpdate::ArrayTypeError < ::ArgumentError
  # @return [ArrayTypeError] a new instance of ArrayTypeError
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#13
  def initialize; end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#24
module ActiveRecord::Acts::List::NoUpdate::ClassMethods
  # Lets you selectively disable all act_as_list database updates
  # for the duration of a block.
  #
  # ==== Examples
  #
  # class TodoList < ActiveRecord::Base
  #   has_many :todo_items, -> { order(position: :asc) }
  # end
  #
  # class TodoItem < ActiveRecord::Base
  #   belongs_to :todo_list
  #
  #   acts_as_list scope: :todo_list
  # end
  #
  # TodoItem.acts_as_list_no_update do
  #   TodoList.first.update(position: 2)
  # end
  #
  # You can also pass an array of classes as an argument to disable database updates on just those classes.
  # It can be any ActiveRecord class that has acts_as_list enabled.
  #
  # ==== Examples
  #
  # class TodoList < ActiveRecord::Base
  #   has_many :todo_items, -> { order(position: :asc) }
  #   acts_as_list
  # end
  #
  # class TodoItem < ActiveRecord::Base
  #   belongs_to :todo_list
  #   has_many :todo_attachments, -> { order(position: :asc) }
  #
  #   acts_as_list scope: :todo_list
  # end
  #
  # class TodoAttachment < ActiveRecord::Base
  #   belongs_to :todo_list
  #   acts_as_list scope: :todo_item
  # end
  #
  # TodoItem.acts_as_list_no_update([TodoAttachment]) do
  #   TodoItem.find(10).update(position: 2)
  #   TodoAttachment.find(10).update(position: 1)
  #   TodoAttachment.find(11).update(position: 2)
  #   TodoList.find(2).update(position: 3) # For this instance the callbacks will be called because we haven't passed the class as an argument
  # end
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#73
  def acts_as_list_no_update(extra_classes = T.unsafe(nil), &block); end

  private

  # @return [Boolean]
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#85
  def active_record_objects?(extra_classes); end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#18
class ActiveRecord::Acts::List::NoUpdate::DisparityClassesError < ::ArgumentError
  # @return [DisparityClassesError] a new instance of DisparityClassesError
  #
  # source://acts_as_list//lib/acts_as_list/active_record/acts/no_update.rb#19
  def initialize; end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/position_column_method_definer.rb#3
module ActiveRecord::Acts::List::PositionColumnMethodDefiner
  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/position_column_method_definer.rb#4
    def call(caller_class, position_column, touch_on_update); end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/position_column_method_definer.rb#15
    def define_class_methods(caller_class, position_column, touch_on_update); end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/position_column_method_definer.rb#58
    def define_instance_methods(caller_class, position_column); end

    # @return [Boolean]
    #
    # source://acts_as_list//lib/acts_as_list/active_record/acts/position_column_method_definer.rb#90
    def mass_assignment_protection_was_used_by_user?(caller_class); end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/position_column_method_definer.rb#96
    def protect_attributes_from_mass_assignment(caller_class, position_column); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/scope_method_definer.rb#4
module ActiveRecord::Acts::List::ScopeMethodDefiner
  extend ::ActiveSupport::Inflector

  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/scope_method_definer.rb#7
    def call(caller_class, scope); end

    # source://acts_as_list//lib/acts_as_list/active_record/acts/scope_method_definer.rb#68
    def idify(caller_class, name); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/sequential_updates_method_definer.rb#3
module ActiveRecord::Acts::List::SequentialUpdatesMethodDefiner
  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/sequential_updates_method_definer.rb#4
    def call(caller_class, column, sequential_updates_option); end
  end
end

# source://acts_as_list//lib/acts_as_list/active_record/acts/top_of_list_method_definer.rb#3
module ActiveRecord::Acts::List::TopOfListMethodDefiner
  class << self
    # source://acts_as_list//lib/acts_as_list/active_record/acts/top_of_list_method_definer.rb#4
    def call(caller_class, top_of_list); end
  end
end
